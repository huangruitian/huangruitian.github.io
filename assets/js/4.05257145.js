(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{370:function(t,a,s){t.exports=s.p+"assets/img/http_gl.2781919e.png"},371:function(t,a,s){t.exports=s.p+"assets/img/tcp_ip.797ef0cd.png"},372:function(t,a,s){t.exports=s.p+"assets/img/get.fdbd4ffe.png"},373:function(t,a,s){t.exports=s.p+"assets/img/URL.92d73c75.png"},374:function(t,a,s){t.exports=s.p+"assets/img/encodeing.2d966923.png"},375:function(t,a,s){t.exports=s.p+"assets/img/chunk.afda1f50.png"},376:function(t,a,s){t.exports=s.p+"assets/img/keep-live.ada335b8.png"},377:function(t,a,s){t.exports=s.p+"assets/img/queue.d99656fa.png"},378:function(t,a,s){t.exports=s.p+"assets/img/cookie.f59fd197.png"},379:function(t,a,s){t.exports=s.p+"assets/img/server-cache.8d20104f.png"},380:function(t,a,s){t.exports=s.p+"assets/img/server-cache2.c25e55ce.png"},381:function(t,a,s){t.exports=s.p+"assets/img/ETag.4121f380.png"},382:function(t,a,s){t.exports=s.p+"assets/img/cache-control.47284f5c.png"},383:function(t,a,s){t.exports=s.p+"assets/img/proxy-cache.09266657.png"},384:function(t,a,s){t.exports=s.p+"assets/img/http_2.8fe2cbd5.png"},385:function(t,a,s){t.exports=s.p+"assets/img/stream.d8fd32a4.png"},386:function(t,a,s){t.exports=s.p+"assets/img/HTTP_vs_HTTP2.83c9f0ec.png"},387:function(t,a,s){t.exports=s.p+"assets/img/qianyan.8903a45c.png"},388:function(t,a,s){t.exports=s.p+"assets/img/hash_table.769dcf95.png"},389:function(t,a,s){t.exports=s.p+"assets/img/dynamic.5fa90e12.png"},390:function(t,a,s){t.exports=s.p+"assets/img/frame.615b49f9.png"},391:function(t,a,s){t.exports=s.p+"assets/img/bao.57b0d181.png"},392:function(t,a,s){t.exports=s.p+"assets/img/liu.68863094.png"},393:function(t,a,s){t.exports=s.p+"assets/img/shuangxiang.b49595a5.png"},394:function(t,a,s){t.exports=s.p+"assets/img/http2_liu.e01b5de5.png"},468:function(t,a,s){"use strict";s.r(a);var e=s(42),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"创世纪"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创世纪"}},[t._v("#")]),t._v(" 创世纪")]),t._v(" "),e("p",[t._v("1989 年，任职于欧洲核子研究中心（CERN）的 "),e("strong",[t._v("蒂姆·伯纳斯 - 李（Tim Berners-Lee）")]),t._v(" 发表了一篇论文，提出了在互联网上构建超链接文档系统的构想，这篇论文中他确立了三项关键技术。")]),t._v(" "),e("ol",[e("li",[t._v("URI：统一资源标识符，作为互联网资源上的唯一身份；")]),t._v(" "),e("li",[t._v("HTML: 即超文本标记语言，描述超文本文档；")]),t._v(" "),e("li",[t._v("HTTP: 即超文本传输协议，用来传输超文本。")])]),t._v(" "),e("p",[t._v("基于这三项关键的技术，人们就可以自由的共享这个世界的信息了，蒂姆把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web，这一边HTTP就诞生了；")]),t._v(" "),e("h2",{attrs:{id:"http-0-9"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-0-9"}},[t._v("#")]),t._v(" HTTP/0.9")]),t._v(" "),e("p",[t._v("20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片“信息荒漠”。\n网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。")]),t._v(" "),e("p",[t._v("这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器和客户端处理，它也采用了"),e("strong",[t._v("纯文本格式")]),t._v("。蒂姆·伯纳斯 - 李最初设想的系统里的文档都是只读的，"),e("strong",[t._v("所以只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接，功能非常有限")]),t._v("。")]),t._v(" "),e("div",{staticClass:"language-! line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("正是因为简单，所以HTTP协议充满了可扩展性。\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("h2",{attrs:{id:"http-1-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0"}},[t._v("#")]),t._v(" HTTP/1.0")]),t._v(" "),e("p",[t._v("1993 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以图文混排的浏览器，随后又在 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。")]),t._v(" "),e("p",[t._v("同一时期，计算机多媒体技术也有了新的发展：1992 年发明了 JPEG 图像格式，1995 年发明了 MP3 音乐格式。")]),t._v(" "),e("p",[t._v("这些技术的推出推动了HTTP协议的发展，经过一系列的草案（在当时并没有成为一个标准），HTTP/1.0 版本在 1996 年正式发布。\n在0.9版本上增加了很多丰富的功能。")]),t._v(" "),e("ul",[e("li",[t._v("增加了POST，HEAD等新方法；")]),t._v(" "),e("li",[t._v("增加了响应状态码，尽可能的标记网络的状态；")]),t._v(" "),e("li",[t._v("引入了协议版本号概念；")]),t._v(" "),e("li",[t._v("引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；")]),t._v(" "),e("li",[t._v("传输的数据不再仅限于文本。")])]),t._v(" "),e("h2",{attrs:{id:"http-1-1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[t._v("#")]),t._v(" HTTP/1.1")]),t._v(" "),e("p",[t._v("1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“浏览器大战”，都希望在互联网上占据主导地位。\n于是在“浏览器大战”结束之后的 1999 年（微软赢了），"),e("strong",[t._v("HTTP/1.1 发布了 RFC 文档，编号为 2616")]),t._v("，正式确立了延续十余年的传奇。\n相比于HTTP/1.0，它是一个正式的标准，也是对HTTP/1.0的小幅度修正。")]),t._v(" "),e("ul",[e("li",[t._v("增加了PUT，DELETE等新方法")]),t._v(" "),e("li",[t._v("增加了缓存管理和控制")]),t._v(" "),e("li",[t._v("明确了连接管理，允许持久连接（默认）；")]),t._v(" "),e("li",[t._v("允许响应头分块，利于传输大文件；")]),t._v(" "),e("li",[t._v("强制要求Host头，让互联网主机托管成为可能；")])]),t._v(" "),e("p",[t._v("不过由于HTTP/1.1过于庞大和复杂，在2014年又做了一次修订，只是将原来的大文档分块，实质性没有做任何的改变；")]),t._v(" "),e("h2",{attrs:{id:"http-2-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-2-0"}},[t._v("#")]),t._v(" HTTP/2.0")]),t._v(" "),e("p",[t._v("经过十余年的发展， HTTP/1.1 标准一直“岿然不动”，显然已经不能满足现在的互联网需求；无奈之下人们只好发明各式各样的“小花招”来缓解这些问题，比如以前常见的切图、JS 合并等网页优化手段。")]),t._v(" "),e("p",[t._v("Chrome 目前的全球的占有率超过了 60%。“挟用户以号令天下”，Google 借此顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。")]),t._v(" "),e("p",[t._v("HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：")]),t._v(" "),e("ul",[e("li",[t._v("二进制协议，不再是纯文本；")]),t._v(" "),e("li",[t._v("可发起多个请求，废弃了 1.1 里的管道；")]),t._v(" "),e("li",[t._v("使用专用算法压缩头部，减少数据传输量；")]),t._v(" "),e("li",[t._v("允许服务器主动向客户端推送数据；")]),t._v(" "),e("li",[t._v("增强了安全性，“事实上”要求加密通信。")])]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 网站控制台允许此函数即可知道支不支持HTTP/2")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 保证这个方法只在支持 loadTimes 的 chrome 浏览器下执行")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("window"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("chrome "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" chrome"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("loadTimes "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'function'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" loadTimes "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" window"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("chrome"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("loadTimes")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" spdy "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" loadTimes"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("wasFetchedViaSpdy"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" info "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" loadTimes"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("npnNegotiatedProtocol "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" loadTimes"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("connectionInfo"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 就以 「h2」作为判断标识")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("spdy "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token regex"}},[e("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[t._v("^h2")]),e("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token regex-flags"}},[t._v("i")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("info"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("info")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'本站点使用了 HTTP/2'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("warn")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'本站点没有使用 HTTP/2'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br")])]),e("h2",{attrs:{id:"http-3-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-3-0"}},[t._v("#")]),t._v(" HTTP/3.0")]),t._v(" "),e("p",[t._v("谷歌在 2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。")]),t._v(" "),e("h2",{attrs:{id:"如何理解-http-有什么特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-http-有什么特点"}},[t._v("#")]),t._v(" 如何理解 HTTP？有什么特点？")]),t._v(" "),e("ol",[e("li",[t._v("超文本传输协议")])]),t._v(" "),e("ul",[e("li",[t._v("超文本：超越了普通文本，可以传输音频视频之类的更多数据；")]),t._v(" "),e("li",[t._v("传输：所谓的“传输”（Transfer）其实很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点搬到 A 点，即“A<===>B”。")]),t._v(" "),e("li",[t._v("协议：协议是约定两方以上的，像我们刚毕业时候的三方协议；")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("特点")])]),t._v(" "),e("ul",[e("li",[t._v("HTTP 协议是一个“双向协议”。也就是说HTTP是轮询机制，一方请求（客户端），一方应答（服务端）。")]),t._v(" "),e("li",[t._v("数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 这两个角色，允许中间有“中转”或者“接力”。")]),t._v(" "),e("li",[t._v("传输方式就从“A<===>B”，变成了“A<=>X<=>B”，A 到 B 的传输过程中可以存在任意多个“中间人”，只要中间人也都遵从 HTTP 协议，就可以添加任意的额外功能，例如HTTPS。")]),t._v(" "),e("li",[t._v("HTTP不是一个孤立的实体（没有实体），需要依赖许多其他的技术来实现，但同时许多技术也都依赖于它。")])]),t._v(" "),e("h2",{attrs:{id:"http-协议橄榄图"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-协议橄榄图"}},[t._v("#")]),t._v(" HTTP 协议橄榄图")]),t._v(" "),e("p",[t._v("往后的内容就以橄榄图展开来讲。\n"),e("img",{attrs:{src:s(370),alt:"alt"}})]),t._v(" "),e("h2",{attrs:{id:"http-预备知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-预备知识"}},[t._v("#")]),t._v(" HTTP 预备知识")]),t._v(" "),e("ol",[e("li",[t._v("浏览器")])]),t._v(" "),e("p",[t._v("浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。当然，为了让我们更好地检索查看网页，它还集成了很多额外的功能。")]),t._v(" "),e("p",[t._v("在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“客户端”。")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("Web 服务器")])]),t._v(" "),e("p",[t._v("它就是提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。比如常用的 Nginx 和 Apache")]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("CDN")])]),t._v(" "),e("p",[t._v("CDN，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。浏览器和服务器之间的中间人，它应用了 HTTP 协议里的"),e("strong",[t._v("缓存和代理技术")]),t._v("，代替源站响应客户端的请求。")]),t._v(" "),e("p",[t._v("那CDN有什么好处呢？")]),t._v(" "),e("p",[t._v("简单来说，因为HTTP/1.1的特性，让浏览器访问图片之类的大文件资源很慢，用户体验极其差，所以可以利用CDN加速；除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分；")]),t._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[t._v("爬虫/HTML/WebService/WAF")])]),t._v(" "),e("ul",[e("li",[t._v("爬虫，抓取互联网的信息数据")]),t._v(" "),e("li",[t._v("HTML 是 HTTP 协议传输的主要内容之一，它描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面。")]),t._v(" "),e("li",[t._v("Web Service，它的名字与 Web Server 很像，但却是一个完全不同的东西。")]),t._v(" "),e("li",[t._v("WAF网络应用防火墙，应用层面的防火墙；")])]),t._v(" "),e("ol",{attrs:{start:"5"}},[e("li",[t._v("TCP/IP\nTCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：TCP 属于“传输层”，IP 属于“网际层”。")])]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("应用层")]),t._v("：浏览器就通过 URI(也常称为URL，URL是URI的子集) 使用 HTTP 协议来请求超文本信息；")]),t._v(" "),e("li",[e("strong",[t._v("传输层")]),t._v("：TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。")]),t._v(" "),e("li",[e("strong",[t._v("网际层（网路层）")]),t._v("：主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。使用IP协议，IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。")]),t._v(" "),e("li",[e("strong",[t._v("链接层")]),t._v("：主要解决局域网（LAN）内的主机和主机之前的通讯；")])]),t._v(" "),e("p",[e("img",{attrs:{src:s(371),alt:"alt"}})]),t._v(" "),e("ol",{attrs:{start:"6"}},[e("li",[t._v("DNS\n人类记忆ip地址很难，于是“域名系统”（Domain Name System）出现了，用有意义的名字来作为 IP 地址的等价替代。")])]),t._v(" "),e("p",[e("strong",[t._v("域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。")])]),t._v(" "),e("p",[t._v("HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。")]),t._v(" "),e("p",[t._v("域名解析：\n"),e("strong",[t._v("就像 IP 地址必须转换（ARP）成 MAC 地址才能访问主机一样，域名也必须要转换成 IP 地址，这个过程就是“域名解析”。")])]),t._v(" "),e("p",[t._v("DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：")]),t._v(" "),e("ul",[e("li",[t._v("根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；")]),t._v(" "),e("li",[t._v("顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；")]),t._v(" "),e("li",[t._v("权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。")])]),t._v(" "),e("p",[t._v("有了这个系统以后，任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，最终就获得了域名对应的 IP 地址。")]),t._v(" "),e("p",[t._v("例如，你要访问“www.apple.com”，就要进行下面的三次查询：")]),t._v(" "),e("ul",[e("li",[t._v("访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；")]),t._v(" "),e("li",[t._v("访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；")]),t._v(" "),e("li",[t._v("最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。")])]),t._v(" "),e("p",[t._v("如果每次都要去查这些DNS服务器，就会非常的慢，所以"),e("strong",[t._v("在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“缓存”。")])]),t._v(" "),e("ul",[e("li",[t._v("许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。例如谷歌的 8.8.8.8")]),t._v(" "),e("li",[t._v("其次，操作系统里也会对 DNS 解析结果做缓存，第二次在浏览器里再输入相同网址的时候就不会再跑到 DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。如果操作系统在缓存里找不到 DNS 记录，就会找“C:\\WINDOWS\\system32\\drivers\\etc\\hosts”这个文件。")])]),t._v(" "),e("p",[t._v("总结如下：")]),t._v(" "),e("ul",[e("li",[t._v("浏览器缓存 -> 操作系统dns cache -> hosts文件 -> 非权威域名服务器 -> 根域名服务器 -> 顶级域名服务器 -> 二级域名服务器 ->权威域名服务器。")]),t._v(" "),e("li",[t._v("非权威域名服务器后面的一般为递归查询，因为内网一般会有防火墙；")])]),t._v(" "),e("ol",{attrs:{start:"7"}},[e("li",[t._v("HTTPS\n"),e("strong",[t._v("在 TCP/IP、DNS 和 URI 的“加持”之下，HTTP 协议终于可以自由地穿梭在互联网世界里，顺利地访问任意的网页了，真的是“好生快活”。")])])]),t._v(" "),e("p",[t._v("但是，互联网上不仅有“美女”，还有很多的“野兽”。")]),t._v(" "),e("p",[t._v("假设你打电话找小明要一份广告创意，很不幸，电话被商业间谍给窃听了，他立刻动用种种手段偷窃了你的快递，就在你还在等包裹的时候，他抢先发布了这份广告，给你的公司造成了无形或有形的损失。")]),t._v(" "),e("p",[t._v("那有什么办法解决这个问题呢？")]),t._v(" "),e("p",[t._v("你和小明约定，用火星文进行通讯，只有你和他知道怎么翻译，这就是HTTPS")]),t._v(" "),e("p",[t._v("HTTPS 就相当于这个比喻中的“火星文”，它的全称是“HTTP over SSL/TLS”，也就是运行在 SSL/TLS 协议上的 HTTP。\n注意它的名字，这里是 SSL/TLS，而不是 TCP/IP，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。")]),t._v(" "),e("ol",{attrs:{start:"8"}},[e("li",[t._v("代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。")])]),t._v(" "),e("p",[t._v("代理有很多的种类，常见的有：")]),t._v(" "),e("ul",[e("li",[t._v("匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；")]),t._v(" "),e("li",[t._v("透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；")]),t._v(" "),e("li",[t._v("正向代理：靠近客户端，代表客户端向服务器发送请求；")]),t._v(" "),e("li",[t._v("反向代理：靠近服务器端，代表服务器响应客户端的请求；")])]),t._v(" "),e("p",[t._v("我们之前提到过的CDN，就是一个匿名代理的实例，由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：")]),t._v(" "),e("ul",[e("li",[t._v("负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；")]),t._v(" "),e("li",[t._v("内容缓存：暂存上下行的数据，减轻后端的压力；")]),t._v(" "),e("li",[t._v("安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；")]),t._v(" "),e("li",[t._v("数据处理：提供压缩、加密等额外的功能。")])]),t._v(" "),e("h2",{attrs:{id:"http-协议结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-协议结构"}},[t._v("#")]),t._v(" HTTP 协议结构")]),t._v(" "),e("p",[t._v("HTTP 协议也是与 TCP/UDP 类似，同样也需要在实际传输的数据前附加一些头数据，不过与 TCP/UDP 不同的是，它是一个“纯文本”的协议，所以头数据都是 ASCII 码的文本，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。")]),t._v(" "),e("p",[t._v("HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：")]),t._v(" "),e("ol",[e("li",[t._v("起始行（start line）：描述请求或响应的基本信息；")]),t._v(" "),e("li",[t._v("头部字段集合（header）：使用 key-value 形式更详细地说明报文；")]),t._v(" "),e("li",[t._v("消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。")])]),t._v(" "),e("p",[t._v("这其中前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”，但与“header”对应，很多时候就直接称为“body”。")]),t._v(" "),e("p",[e("strong",[t._v("HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。")])]),t._v(" "),e("p",[t._v("HTTP协议报文就像一个大头儿子，报文里的 header 就是“大头儿子”的“大头”，空行就是他的“脖子”，而后面的 body 部分就是他的身体了。如下图："),e("strong",[t._v("请求行 + 请求体 + 空白行 + body(此报文没有body)")])]),t._v(" "),e("p",[e("img",{attrs:{src:s(372),alt:"alt"}})]),t._v(" "),e("h3",{attrs:{id:"请求行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求行"}},[t._v("#")]),t._v(" 请求行")]),t._v(" "),e("p",[t._v("了解 HTTP 报文的基本结构后，我们来看看请求报文里的起始行也就是请求行（request line），它简要地描述了客户端想要如何操作服务器端的资源。")]),t._v(" "),e("p",[t._v("请求行由三部分构成：")]),t._v(" "),e("ol",[e("li",[t._v("请求方法：是一个动词，如 GET/POST，表示对资源的操作；")]),t._v(" "),e("li",[t._v("请求目标：通常是一个 URI，标记了请求方法要操作的资源；")]),t._v(" "),e("li",[t._v("版本号：表示报文使用的 HTTP 协议版本。")])]),t._v(" "),e("p",[t._v("这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。")]),t._v(" "),e("p",[t._v("比如一个GET请求行，"),e("code",[t._v("GET / HTTP/1.1")])]),t._v(" "),e("h3",{attrs:{id:"状态行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#状态行"}},[t._v("#")]),t._v(" 状态行")]),t._v(" "),e("p",[t._v("看完了请求行，我们再看响应报文里的起始行，在这里它不叫“响应行”，而是叫“状态行”（status line），意思是服务器响应的状态")]),t._v(" "),e("p",[t._v("同样也是由三部分构成：")]),t._v(" "),e("ol",[e("li",[t._v("版本号：表示报文使用的HTTP协议版本；")]),t._v(" "),e("li",[t._v("状态码：一个三位数，用代码的形式表示处理结果，比如200是成功，500是错误；")]),t._v(" "),e("li",[t._v("原因：作为数字状态码的补充，帮助人理解原因；")])]),t._v(" "),e("p",[t._v("比如一个GET响应，"),e("code",[t._v("HTTP/1.1 200 OK")])]),t._v(" "),e("h2",{attrs:{id:"头部字段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#头部字段"}},[t._v("#")]),t._v(" 头部字段")]),t._v(" "),e("p",[t._v("请求头和响应头的结构是基本一样的，唯一的区别是起始行，所以把请求头和响应头里的字段放在一起介绍。")]),t._v(" "),e("p",[t._v("头部字段是key-value 的形式，key和value之间用一个“:”分割，最后用 CRLF 换行表示字段结束。比如在“Host: 127.0.0.1”这一行里 key 就是“Host”，value 就是“127.0.0.1”。")]),t._v(" "),e("p",[e("strong",[t._v("HTTP的头部字段非常的灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。")])]),t._v(" "),e("p",[t._v("不过使用头字段需要注意下面几点：")]),t._v(" "),e("ol",[e("li",[t._v("字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；")]),t._v(" "),e("li",[t._v("字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；")]),t._v(" "),e("li",[t._v("字段名（key）后面必须紧接着“:”，不能有空格，而“:”后的字段值（vlaue）前可以有多个空格；")]),t._v(" "),e("li",[t._v("字段的顺序是没有意义的，可以任意排列不影响语义；")]),t._v(" "),e("li",[t._v("字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。")])]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 合法，会正确返回响应报文")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("GET")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("09")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HTTP")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.1")]),t._v("\nHost"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("   www"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("test"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("com\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 不合法，不符合条件3，返回状态码 400 Bad Request")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("GET")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("09")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HTTP")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.1")]),t._v("\nHost "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" www"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("test"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("com\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br")])]),e("h3",{attrs:{id:"常用的头字段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用的头字段"}},[t._v("#")]),t._v(" 常用的头字段")]),t._v(" "),e("p",[t._v("对 HTTP 报文的解析和处理实际上主要就是对头字段的处理，理解了头字段也就理解了 HTTP 报文。\nHTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("通用头字段(General)")]),t._v("：在请求头和响应头里都可以出现；")])]),t._v(" "),e("ul",[e("li",[t._v("Date 字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[e("strong",[t._v("请求头字段(Request Headers)")]),t._v("：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；")])]),t._v(" "),e("ul",[e("li",[t._v("Host 字段，它属于请求字段，只能出现在请求头里，它同时也是唯一一个 "),e("strong",[t._v("HTTP/1.1 规范里要求必须出现的字段")]),t._v("，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。")]),t._v(" "),e("li",[t._v("User-Agent 是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。")])]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[e("strong",[t._v("响应头字段(Response Headers)")]),t._v("：仅能出现在响应头里，补充说明响应报文的信息；")])]),t._v(" "),e("ul",[e("li",[t._v("Server 字段是响应字段，只能出现在响应头里。提供服务器信息。")])]),t._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[e("strong",[t._v("实体头字段")]),t._v("：它实际上属于通用字段，但专门描述 body 的额外信息。")])]),t._v(" "),e("ul",[e("li",[t._v("Content-Length，如果没有这个字段，body就是不定长的，需要使用 chunked 方式分段传输。")])]),t._v(" "),e("h2",{attrs:{id:"标准请求方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标准请求方法"}},[t._v("#")]),t._v(" 标准请求方法")]),t._v(" "),e("p",[t._v("很显然，需要有某种“动作的指示”，告诉操作这些资源的方式。所以，就这么出现了“请求方法”。它的实际含义就是客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作。")]),t._v(" "),e("p",[t._v("目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式，对常用的加以解释；")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("GET")]),t._v("：获取资源，可以理解为读取或者下载数据；")]),t._v(" "),e("li",[e("strong",[t._v("HEAD")]),t._v("：获取资源的元信息（轻量版GET）；")]),t._v(" "),e("li",[e("strong",[t._v("POST")]),t._v("：向资源提交数据，相当于写入或上传数据；")]),t._v(" "),e("li",[e("strong",[t._v("PUT")]),t._v("：类似 POST；")]),t._v(" "),e("li",[t._v("DELETE：删除资源；")]),t._v(" "),e("li",[t._v("CONNECT：建立特殊的连接隧道；")]),t._v(" "),e("li",[e("strong",[t._v("OPTIONS")]),t._v("：列出可对资源实行的方法；")]),t._v(" "),e("li",[t._v("TRACE：追踪请求 - 响应的传输路径。")])]),t._v(" "),e("h3",{attrs:{id:"get-head"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#get-head"}},[t._v("#")]),t._v(" GET/HEAD")]),t._v(" "),e("p",[t._v("GET是请求"),e("strong",[t._v("从服务器获取资源")]),t._v("，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。")]),t._v(" "),e("p",[t._v("GET 方法虽然基本动作比较简单，但搭配 URI 和其他头字段就能实现对资源更精细的操作。")]),t._v(" "),e("p",[t._v("例如，在 URI 后使用“#”，就可以在获取页面后直接定位到某个标签所在的位置；使用 If-Modified-Since 字段就变成了“有条件的请求”，仅当资源被修改时才会执行获取动作；使用 Range 字段就是“范围请求”，只获取资源的一部分数据。")]),t._v(" "),e("p",[t._v("HEAD 方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。")]),t._v(" "),e("h3",{attrs:{id:"post-put"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#post-put"}},[t._v("#")]),t._v(" POST/PUT")]),t._v(" "),e("p",[t._v("GET 和 HEAD 方法是从服务器获取数据，而 POST 和 PUT 方法则是相反操作，向 URI 指定的资源提交数据，数据就放在报文的 body 里。")]),t._v(" "),e("p",[t._v("比如，你上论坛灌水，敲了一堆字后点击“发帖”按钮，浏览器就执行了一次 POST 请求，把你的文字放进报文的 body 里，然后拼好 POST 请求头，通过 TCP 协议发给服务器。")]),t._v(" "),e("p",[t._v("PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 POST 表示的是“新建”“create”的含义，而 PUT 则是“修改”“update”的含义。")]),t._v(" "),e("p",[t._v("在实际应用中，PUT 用到的比较少。而且，因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据。")]),t._v(" "),e("h3",{attrs:{id:"options"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#options"}},[t._v("#")]),t._v(" OPTIONS")]),t._v(" "),e("p",[t._v("跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。")]),t._v(" "),e("p",[t._v("服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。")]),t._v(" "),e("p",[t._v("在前端最常用的 cors 跨域中，浏览器都是用 OPTIONS 方法发预检请求的")]),t._v(" "),e("h3",{attrs:{id:"简单请求与复杂请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简单请求与复杂请求"}},[t._v("#")]),t._v(" 简单请求与复杂请求")]),t._v(" "),e("ol",[e("li",[t._v("简单请求")])]),t._v(" "),e("ul",[e("li",[t._v("请求方法为GET、HEAD、POST时发的请求")]),t._v(" "),e("li",[t._v("人为设置了规范集合之内的首部字段，如Accept/Accept-Language/Content-Language/Content-Type/DPR/Downlink/Save-Data/Viewport-Width/Width")]),t._v(" "),e("li",[t._v("Content-Type 的值仅限于下列三者之一,即application/x-www-form-urlencoded、multipart/form-data、text/plain")]),t._v(" "),e("li",[t._v("请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器；")]),t._v(" "),e("li",[t._v("请求中没有使用 ReadableStream 对象。")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("复杂请求")])]),t._v(" "),e("ul",[e("li",[t._v("使用了下面任一 HTTP 方法，PUT/DELETE/CONNECT/OPTIONS/TRACE/PATCH")]),t._v(" "),e("li",[t._v("人为设置了以下集合之外首部字段，即简单请求外的字段")]),t._v(" "),e("li",[t._v("Content-Type 的值不属于下列之一，即application/x-www-form-urlencoded、multipart/form-data、text/plain")])]),t._v(" "),e("p",[t._v("当触发预检时，跨域请求便会发送 2 次请求，既增加了请求数，也延迟了请求真正发起的时间，严重影响性能。")]),t._v(" "),e("p",[t._v("所以，我们可以优化 Options 请求，主要有 2 种方法：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("转为简单请求，如用 JSONP 做跨域请求")])]),t._v(" "),e("li",[e("p",[t._v("对 options 请求进行缓存，服务器端设置 Access-Control-Max-Age 字段，那么当第一次请求该 URL 时会发出 OPTIONS 请求，浏览器会根据返回的 Access-Control-Max-Age 字段缓存该请求的 OPTIONS 预检请求的响应结果（具体缓存时间还取决于浏览器的支持的默认最大值，取两者最小值，一般为 10 分钟）。在缓存有效期内，该资源的请求（URL 和 header 字段都相同的情况下）不会再触发预检。（chrome 打开控制台可以看到，当服务器响应 Access-Control-Max-Age 时只有第一次请求会有预检，后面不会了。注意要开启缓存，去掉 disable cache 勾选。）")])])]),t._v(" "),e("h3",{attrs:{id:"get-和-post的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post的区别"}},[t._v("#")]),t._v(" GET 和 POST的区别")]),t._v(" "),e("ol",[e("li",[t._v("从安全角度，POST相对安全点，而GET直接暴露在URL上")]),t._v(" "),e("li",[t._v("从幂等性角度，POST是非幂等的，GET幂等")]),t._v(" "),e("li",[t._v("从编码角度，GET只支持ASCII码，POST没有限制")]),t._v(" "),e("li",[t._v("从缓存角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。")]),t._v(" "),e("li",[t._v("从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)")])]),t._v(" "),e("h3",{attrs:{id:"扩展方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#扩展方法"}},[t._v("#")]),t._v(" 扩展方法")]),t._v(" "),e("p",[t._v("虽然 HTTP/1.1 里规定了八种请求方法，但它并没有限制我们只能用这八种方法，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。")]),t._v(" "),e("h2",{attrs:{id:"安全与幂等"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#安全与幂等"}},[t._v("#")]),t._v(" 安全与幂等")]),t._v(" "),e("p",[t._v("在 HTTP 协议里，所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。")]),t._v(" "),e("p",[t._v("所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。")]),t._v(" "),e("p",[t._v("很显然，GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。")]),t._v(" "),e("p",[t._v("POST相当于SQL插入语句，PUT相当于更新语句，所以POST是非幂等的，而PUT是幂等的")]),t._v(" "),e("h2",{attrs:{id:"url"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#url"}},[t._v("#")]),t._v(" URL")]),t._v(" "),e("p",[t._v("URI 不完全等同于网址，它包含有 URL 和 URN 两个部分，在 HTTP 世界里用的网址实际上是 URL——统一资源定位符（Uniform Resource Locator）。但因为 URL 实在是太普及了，所以常常把这两者简单地视为相等。实际上URL是URI的子集。\n"),e("img",{attrs:{src:s(373),alt:"alt"}})]),t._v(" "),e("ol",[e("li",[t._v("scheme：翻译成中文叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问。")]),t._v(" "),e("li",[t._v("三个特定的字符：在 scheme 之后，必须是三个特定的字符“: //”，它把 scheme 和后面的部分分离开。")]),t._v(" "),e("li",[t._v("host:port：在“: //”之后，是被称为“authority”的部分，表示资源所在的主机名，通常的形式是“host:port”，即主机名加端口号，"),e("strong",[t._v("HTTP默认使用的是80，HTTPS则是443。")])]),t._v(" "),e("li",[t._v("path：有了协议名和主机地址、端口号，再加上后面标记资源所在位置的 path，浏览器就可以连接服务器访问资源了。")]),t._v(" "),e("li",[t._v("query：它在 path 之后，用一个“?”开始，但不包含“?”，表示对资源附加的额外要求。")])]),t._v(" "),e("ul",[e("li",[t._v("查询参数 query 有一套自己的格式，是多个“key=value”的字符串，这些 KV 值用字符“&”连接，浏览器和服务器都可以按照这个格式把长串的查询参数解析成可理解的字典或关联数组形式。在 URI 里只能使用 ASCII 码，对于 ASCII 码以外的字符集和特殊字符进行转码；")])]),t._v(" "),e("ol",{attrs:{start:"6"}},[e("li",[t._v("其实完整URI格式，还存在主机名之前的身份信息“user:passwd@” 和 查询参数后的片段标识符“#fragment”；但片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。而身份信息会造成安全问题所以这两个是不常用的。")])]),t._v(" "),e("h2",{attrs:{id:"状态码该怎么用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#状态码该怎么用"}},[t._v("#")]),t._v(" 状态码该怎么用？")]),t._v(" "),e("p",[t._v("目前 RFC 标准里总共有 41 个状态码，但状态码的定义是开放的，允许自行扩展。")]),t._v(" "),e("ul",[e("li",[t._v("1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；")]),t._v(" "),e("li",[t._v("2××：成功，报文已经收到并被正确处理；")]),t._v(" "),e("li",[t._v("3××：重定向，资源位置发生变动，需要客户端重新发送请求；")]),t._v(" "),e("li",[t._v("4××：客户端错误，请求报文有误，服务器无法处理；")]),t._v(" "),e("li",[t._v("5××：服务器错误，服务器在处理请求时内部发生了错误。")])]),t._v(" "),e("p",[t._v("在 HTTP 协议中，正确地理解并应用这些状态码不是客户端或服务器单方的责任，而是双方共同的责任。")]),t._v(" "),e("p",[t._v("客户端作为请求的发起方，获取响应报文后，需要通过状态码知道请求是否被正确处理，是否要再次发送请求，如果出错了原因又是什么。这样才能进行下一步的动作，要么发送新请求，要么改正错误重发请求。")]),t._v(" "),e("p",[t._v("服务器端作为请求的接收方，也应该很好地运用状态码。在处理请求时，选择最恰当的状态码回复客户端，告知客户端处理的结果，指示客户端下一步应该如何行动。特别是在出错的时候，尽量不要简单地返 400、500 这样意思含糊不清的状态码。")]),t._v(" "),e("p",[t._v("因为状态码的含糊不清，通常都会返回一个规定好的结构体辅助判断，如下所示")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//状态码，一般规定0为成功，其它的为错误，错误了一般msg会给出精确的提示；")]),t._v("\n   code"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n   msg"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'缺少xxx参数'")]),t._v(" \n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br")])]),e("p",[t._v("我们再挑一些有价值的状态码学习一下")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("“101 Switching Protocols” 它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。")])]),t._v(" "),e("li",[e("p",[t._v("“200 OK”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。")])]),t._v(" "),e("li",[e("p",[t._v("“204 No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。")])]),t._v(" "),e("li",[e("p",[t._v("“206 Partial Content”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。")])]),t._v(" "),e("li",[e("p",[t._v("“301 Moved Permanently”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。")])]),t._v(" "),e("li",[e("p",[t._v("与它类似的是“302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。")])])]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。")])])]),t._v(" "),e("ol",{attrs:{start:"7"}},[e("li",[e("p",[t._v("“304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。")])]),t._v(" "),e("li",[e("p",[t._v("“400 Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。")])]),t._v(" "),e("li",[e("p",[t._v("“403 Forbidden”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。")])]),t._v(" "),e("li",[e("p",[t._v("“404 Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。")])])]),t._v(" "),e("h2",{attrs:{id:"http特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http特点"}},[t._v("#")]),t._v(" HTTP特点")]),t._v(" "),e("ol",[e("li",[t._v("灵活可扩展")]),t._v(" "),e("li",[t._v("可靠传输（基于TCP）")]),t._v(" "),e("li",[t._v("应用层协议")])]),t._v(" "),e("ul",[e("li",[t._v("HTTP 凭借着可携带任意头字段和实体数据的报文结构，以及连接控制、缓存代理等方便易用的特性，一出现就“技压群雄”，迅速成为了应用层里的“明星”协议。只要不太苛求性能，HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议。")])]),t._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[t._v("请求 - 应答")]),t._v(" "),e("li",[t._v("无状态")])]),t._v(" "),e("ul",[e("li",[t._v("所谓无状态，就是“没有记忆能力”，不保存本次连接的执行上下文")])]),t._v(" "),e("h2",{attrs:{id:"http优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http优缺点"}},[t._v("#")]),t._v(" HTTP优缺点")]),t._v(" "),e("ol",[e("li",[t._v("简单、灵活、易于扩展（优点）")]),t._v(" "),e("li",[t._v("应用广泛、环境成熟，跨语言、跨平台（优点）")]),t._v(" "),e("li",[t._v("无状态，对于需要记忆状态的场景是缺点（可以利用cookie），不需要记忆状态的是优点（双刃剑）")]),t._v(" "),e("li",[t._v("明文，免费 WiFi 陷阱可以窃听你的一切信息（双刃剑，我觉得是缺点）")]),t._v(" "),e("li",[t._v("不安全，没有身份认证（伪装）和完整性校验（篡改），身份认证”简单来说就是“怎么证明你就是你”。")]),t._v(" "),e("li",[t._v("性能，不算好也不算坏，“请求 - 应答”模式则加剧了 HTTP 的性能问题，这就是著名的“队头阻塞”（Head-of-line blocking），当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。")])]),t._v(" "),e("h2",{attrs:{id:"数据类型使用的头字段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据类型使用的头字段"}},[t._v("#")]),t._v(" 数据类型使用的头字段")]),t._v(" "),e("p",[t._v("在 TCP/IP 协议栈里，传输数据基本上都是“header+body”的格式。但 TCP、UDP 因为是传输层的协议，它们不会关心 body 数据是什么，只要把数据发送到对方就算是完成了任务。")]),t._v(" "),e("p",[t._v("而 HTTP 协议则不同，它是应用层的协议，数据到达之后工作只能说是完成了一半，还必须要告诉上层应用这是什么数据才行，否则上层应用就会“不知所措”。")]),t._v(" "),e("p",[t._v("当然HTTP可以靠“猜”。但是效率太低了，所以需要利用一些字段说明发送的数据类型；")]),t._v(" "),e("p",[t._v("HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 实体头字段，用于客户端和服务器进行“内容协商”。也就是说，客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("Accept")]),t._v(" 字段标记的是客户端可理解的 MIME type，可以用“,”做分隔符列出多个类型，让服务器有更多的选择余地，例如下面的这个头：")])]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("Accept"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" text"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("html"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("application"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("xml"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("image"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("webp"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("image"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("png\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 客户端一般也会加上权重（1最大），供服务器计算选择")]),t._v("\nAccept"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" text"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("html"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("application"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("xml"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("q"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.9")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*;q=0.8\n")])])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("ol",{attrs:{start:"2"}},[e("li",[e("strong",[t._v("Content-Type")]),t._v(" 是实体字段，请求和响应里都可以用，作用是指明body数据的类型。在响应报文里，告诉实体数据的真实类型，例如：")])]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// text/html 这种是MIME type类型，更多类型可以查阅文档")]),t._v("\nContent"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Type"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" text"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("html "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//浏览器看不到这个就会渲染页面")]),t._v("\nContent"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Type"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" image"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("png "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//浏览器看到这个就会再页面上显示图片")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("ol",{attrs:{start:"3"}},[e("li",[e("strong",[t._v("Accept-Encoding/Content-Encoding")]),t._v("，可以省略，前者表示客户端压缩方式，后者表示服务端的返回数据有没有被压缩")])]),t._v(" "),e("ul",[e("li",[t._v("常用的有 gzip")])]),t._v(" "),e("h2",{attrs:{id:"语言类型和编码使用的头字段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语言类型和编码使用的头字段"}},[t._v("#")]),t._v(" 语言类型和编码使用的头字段")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("Accept-Language/Content-Language")])])]),t._v(" "),e("ul",[e("li",[t._v("Accept-Language 字段标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型；")]),t._v(" "),e("li",[t._v("Content-Language 相应的，服务器应该在响应报文里用这个头字段告诉客户端实体数据使用的实际语言类型：")])]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用中文，英文")]),t._v("\nAccept"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Language"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" zh"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CN")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" zh"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" en\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用中文")]),t._v("\nContent"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Language"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" zh"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CN")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("ol",{attrs:{start:"2"}},[e("li",[e("strong",[t._v("Accept-Charset/Content-Type")])])]),t._v(" "),e("ul",[e("li",[t._v("字符集在 HTTP 里使用的请求头字段是 Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在 Content-Type 字段的数据类型后面用“charset=xxx”来表示，这点需要特别注意。")])]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 浏览器请求 GBK 或 UTF-8 的字符集")]),t._v("\nAccept"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Charset"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" gbk"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" utf"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 服务器返回的是 UTF-8 编码")]),t._v("\nContent"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Type"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" text"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("html"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" charset"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("utf"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("p",[t._v("不过现在的浏览器都支持多种字符集，通常不会发送 Accept-Charset，而服务器也不会发送 Content-Language，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 Accept-Language 字段，响应头里只会有 Content-Type 字段。")]),t._v(" "),e("ul",[e("li",[t._v("最后总给一下来张图吧")])]),t._v(" "),e("p",[e("img",{attrs:{src:s(374),alt:"alt"}})]),t._v(" "),e("h2",{attrs:{id:"化整为零-分块传输"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#化整为零-分块传输"}},[t._v("#")]),t._v(" 化整为零，分块传输")]),t._v(" "),e("p",[t._v("通常浏览器在发送请求时都会带着“Accept-Encoding”头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br 等，这样服务器就可以从中选择一种压缩算法，放进“Content-Encoding”响应头里，再把原数据压缩后发给浏览器。")]),t._v(" "),e("p",[t._v("不过这个解决方法也有个缺点，gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。")]),t._v(" "),e("p",[t._v("在数据压缩之外，还能有什么办法来解决大文件的问题呢？")]),t._v(" "),e("p",[t._v("利用“化整为零”的思路在 HTTP 协议里就是“chunked”分块传输编码，在响应报文里用头字段“Transfer-Encoding: chunked”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。")]),t._v(" "),e("p",[t._v("“Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked），这一点你一定要记住。")]),t._v(" "),e("p",[t._v("下面我们来看一下分块传输的编码规则，其实也很简单，同样采用了明文的方式，很类似响应头。")]),t._v(" "),e("ol",[e("li",[t._v("每个分块包含两个部分，长度头和数据块；")]),t._v(" "),e("li",[t._v("长度头是以 CRLF（回车换行，即\\r\\n）结尾的一行明文，用 16 进制数字表示长度；")]),t._v(" "),e("li",[t._v("数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；")]),t._v(" "),e("li",[t._v("最后用一个长度为 0 的块表示结束，即“0\\r\\n\\r\\n”。")])]),t._v(" "),e("p",[e("img",{attrs:{src:s(375),alt:"alt"}})]),t._v(" "),e("h2",{attrs:{id:"范围请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#范围请求"}},[t._v("#")]),t._v(" 范围请求")]),t._v(" "),e("p",[t._v("有了分块传输编码，服务器就可以轻松地收发大文件了，但对于上 G 的超大文件，还有一些问题需要考虑。")]),t._v(" "),e("p",[t._v("比如，你看电视剧前面有广告，想拖进进度条，避开广告，这实际上就是获取大文件的一个片段，而分块传输并没有这个能力。")]),t._v(" "),e("p",[t._v("HTTP 协议为了满足这样的需求，提出了“范围请求”（range requests）的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”。")]),t._v(" "),e("p",[t._v("范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“Accept-Ranges: bytes”明确告知客户端：“我是支持范围请求的”。如果省略或者值为none，客户端就会认为没有实现范围请求；只能老老实实的收发整个文件；")]),t._v(" "),e("p",[t._v("请求头 Range 是 HTTP 范围请求的专用字段，格式是“bytes=x-y”，其中的 x 和 y 是以字节为单位的数据范围，是偏移量。")]),t._v(" "),e("p",[t._v("当服务器收到 Range 字段后，需要做四件事。")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码 416，意思是“你的范围请求有误，我无法处理，请再检查一下”。")])]),t._v(" "),e("li",[e("p",[t._v("如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“206 Partial Content”，和 200 的意思差不多，但表示 body 只是原数据的一部分。")])]),t._v(" "),e("li",[e("p",[t._v("服务器要添加一个响应头字段 Content-Range，告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。")])]),t._v(" "),e("li",[e("p",[t._v("最后剩下的就是发送数据了，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了。")])])]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 范围请求")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("GET")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HTTP")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.1")]),t._v("\nHost"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" www"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("test"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("com\nRange"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" bytes"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("31")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回的数据是（去掉了几个无关字段）")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HTTP")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.1")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("206")]),t._v(" Partial Content\nContent"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Length"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("32")]),t._v("\nAccept"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Ranges"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" bytes\nContent"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Range"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" bytes "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("31")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("96")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br")])]),e("p",[t._v("刚才说的范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个“x-y”，一次性获取多个片段数据。")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 发出两个范围请求")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("GET")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HTTP")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.1")]),t._v("\nHost"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" www"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("chrono"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("com\nRange"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" bytes"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("29")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 响应报文里的“- -00000000001”就是多段的分隔符")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HTTP")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.1")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("206")]),t._v(" Partial Content\nContent"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Type"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" multipart"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("byteranges"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" boundary"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("00000000001")]),t._v("\nContent"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Length"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("189")]),t._v("\nConnection"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" keep"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("alive\nAccept"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Ranges"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" bytes\n\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("00000000001")]),t._v("\nContent"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Type"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" text"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("plain\nContent"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Range"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" bytes "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("96")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("00000000001")]),t._v("\nContent"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Type"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" text"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("plain\nContent"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Range"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" bytes "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("29")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("96")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("00000000001")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br"),e("span",{staticClass:"line-number"},[t._v("19")]),e("br"),e("span",{staticClass:"line-number"},[t._v("20")]),e("br"),e("span",{staticClass:"line-number"},[t._v("21")]),e("br")])]),e("p",[t._v("最后，要特别注意，"),e("strong",[t._v("分段的range和分块的chunk是两个完全无关的概念，不要弄混了。chunk是传输时分成小块逐个发送，range是取大文件中间的一部分。")])]),t._v(" "),e("h2",{attrs:{id:"http的连接管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http的连接管理"}},[t._v("#")]),t._v(" HTTP的连接管理")]),t._v(" "),e("ol",[e("li",[t._v("短链接")])]),t._v(" "),e("p",[t._v("HTTP 协议最初（0.9/1.0）是个非常简单的协议，通信过程也采用了简单的“请求 - 应答”方式。")]),t._v(" "),e("p",[t._v("它底层的数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。")]),t._v(" "),e("p",[t._v("因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为“短连接”（short-lived connections）。早期的 HTTP 协议也被称为是“无连接”的协议。")]),t._v(" "),e("p",[t._v("就好比，你吃饭，每次只能盛一勺饭，放到碗里，然后吃了重复这个动作；显然是很浪费时间的；")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("长连接(HTTP/1.1 默认启用)")])]),t._v(" "),e("p",[t._v("针对短连接暴露出的缺点，HTTP 协议就提出了“长连接”的通信方式，也叫“持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(376),alt:"alt"}})]),t._v(" "),e("p",[t._v("不过不管客户端是否显式要求长连接，如果服务器支持长连接，它总会在响应报文里放一个“Connection: keep-alive”字段，告诉客户端：“我是支持长连接的，接下来就用这个 TCP 一直收发数据吧”。")]),t._v(" "),e("p",[t._v("不过长连接也会有一些小缺点，如果得不到恰当的关闭，会耗尽服务器的资源；")]),t._v(" "),e("p",[t._v("在客户端上，可以在请求头里加上“Connection: close”字段，告诉服务器：“这次通信后就关闭连接”。")]),t._v(" "),e("p",[t._v("而在服务端上，一般不会主动关闭，而是利用一些有效的策略，比如超时时间等等；")]),t._v(" "),e("h3",{attrs:{id:"队头阻塞"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#队头阻塞"}},[t._v("#")]),t._v(" 队头阻塞")]),t._v(" "),e("p",[t._v("“队头阻塞”与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。")]),t._v(" "),e("p",[t._v("因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。")]),t._v(" "),e("p",[t._v("如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(377),alt:"alt"}})]),t._v(" "),e("h3",{attrs:{id:"性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),e("p",[t._v("因为“请求 - 应答”模型不能变，所以“队头阻塞”问题在 HTTP/1.1 里无法解决，只能缓解，有什么办法呢？")]),t._v(" "),e("p",[e("strong",[t._v("数量解决质量")]),t._v("，这在 HTTP 里就是“并发连接”（concurrent connections），也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。")]),t._v(" "),e("p",[t._v("所以，RFC2616 里明确限制每个客户端最多并发 2 个连接。不过实践证明这个数字实在是太小了，众多浏览器都“无视”标准，把这个上限提高到了 6~8。后来修订的 RFC7230 也就“顺水推舟”，取消了这个“2”的限制。")]),t._v(" "),e("p",[t._v("还有个办法就是"),e("strong",[t._v("域名分片")]),t._v("，HTTP 协议和浏览器不是限制并发连接数量吗？")]),t._v(" "),e("p",[t._v("好，那我就多开几个域名，比如 shard1.test.com、shard2.test.com，而这些域名都指向同一台服务器 www.test.com，这样实际长连接的数量就又上去了，真是“美滋滋”。不过实在是有点“上有政策，下有对策”的味道。")]),t._v(" "),e("h2",{attrs:{id:"重定向和跳转"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重定向和跳转"}},[t._v("#")]),t._v(" 重定向和跳转")]),t._v(" "),e("p",[t._v("跳转动作是由浏览器的使用者主动发起的，可以称为“主动跳转”，但还有一类跳转是由服务器来发起的，浏览器使用者无法控制，相对地就可以称为“被动跳转”，这在 HTTP 协议里有个专门的名词，叫做“重定向”（Redirection）。")]),t._v(" "),e("p",[t._v("被动跳转是响应报文返回重定向状态码（如 301/302），配合“Location”字段。它标记了服务器要求重定向的 URI，也就是要求浏览器跳转到“Location”字段的URI上。")]),t._v(" "),e("p",[t._v("在“Location”里的 URI 既可以使用绝对 URI，也可以使用相对 URI。所谓“绝对 URI”，就是完整形式的 URI，包括 scheme、host:port、path 等。所谓“相对 URI”，就是省略了 scheme 和 host:port，只有 path 和 query 部分，是不完整的，但可以从请求上下文里计算得到。注意，站外不能使用“相对 URI”。")]),t._v(" "),e("h3",{attrs:{id:"重定向状态码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重定向状态码"}},[t._v("#")]),t._v(" 重定向状态码")]),t._v(" "),e("ul",[e("li",[t._v("301 俗称“永久重定向”（Moved Permanently），意思是原 URI 已经“永久”性地不存在了，今后的所有请求都必须改用新的 URI。")]),t._v(" "),e("li",[t._v("302 俗称“临时重定向”（“Moved Temporarily”），意思是原 URI 处于“临时维护”状态，新的 URI 是起“顶包”作用的“临时工”")]),t._v(" "),e("li",[t._v("303 See Other：类似 302，但要求重定向后的请求改为 GET 方法，访问一个结果页面，避免 POST/PUT 重复操作；")]),t._v(" "),e("li",[t._v("307 Temporary Redirect：类似 302，但重定向后请求里的方法和实体不允许变动，含义比 302 更明确；")]),t._v(" "),e("li",[t._v("308 Permanent Redirect：类似 307，不允许重定向后的请求变动，但它是 301“永久重定向”的含义。")])]),t._v(" "),e("h2",{attrs:{id:"cookie"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[t._v("#")]),t._v(" Cookie")]),t._v(" "),e("p",[t._v("HTTP 是“无状态”的，这既是优点也是缺点。优点是服务器没有状态差异，可以很容易地组成集群，而缺点就是无法支持需要记录状态的事务操作。")]),t._v(" "),e("p",[t._v("好在 HTTP 协议是可扩展的，后来发明的 Cookie 技术，给 HTTP 增加了“记忆能力”。")]),t._v(" "),e("p",[t._v("HTTP 的 Cookie 机制原理，就相当于是服务器给每个客户端都贴上一张小纸条，上面写了一些只有服务器才能理解的数据，需要的时候客户端把这些信息发给服务器，服务器看到 Cookie，就能够认出对方是谁了。")]),t._v(" "),e("h3",{attrs:{id:"cookie-的工作过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie-的工作过程"}},[t._v("#")]),t._v(" Cookie 的工作过程")]),t._v(" "),e("p",[t._v("那么，Cookie 这张小纸条是怎么传递的呢？")]),t._v(" "),e("p",[t._v("这要用到两个字段：响应头字段 Set-Cookie 和请求头字段 Cookie。直接看图你就明白了，一图胜千言；")]),t._v(" "),e("p",[e("img",{attrs:{src:s(378),alt:"alt"}})]),t._v(" "),e("p",[t._v("Cookie 是由浏览器负责存储的，而不是操作系统。所以，它是“浏览器绑定”的，只能在本浏览器内生效。")]),t._v(" "),e("h3",{attrs:{id:"cookie-的属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie-的属性"}},[t._v("#")]),t._v(" Cookie 的属性")]),t._v(" "),e("p",[t._v("Cookie有“保鲜期”的，让它只能在一段时间内可用，就像是食品的“保鲜期”，一旦超过这个期限浏览器就认为是 Cookie 失效，在存储里删除，也不会发送给服务器。")]),t._v(" "),e("p",[t._v("Cookie 的有效期可以使用 Expires 和 Max-Age 两个属性来设置。")]),t._v(" "),e("ul",[e("li",[t._v("Expires 俗称“过期时间”，用的是绝对时间点，可以理解为“截止日期”（deadline）")]),t._v(" "),e("li",[t._v("Max-Age 用的是相对时间，单位是秒，浏览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时间。")])]),t._v(" "),e("p",[t._v("Expires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会优先采用 Max-Age 计算失效期。")]),t._v(" "),e("p",[t._v("比如在这个例子里，Expires 标记的过期时间是“GMT 2019 年 6 月 7 号 8 点 19 分”，而 Max-Age 则只有 10 秒，如果现在是 6 月 6 号零点，那么 Cookie 的实际有效期就是“6 月 6 号零点过 10 秒”。")]),t._v(" "),e("p",[t._v("其次，我们需要设置 Cookie 的作用域，让浏览器仅发送给特定的服务器和 URI，避免被其他网站盗用。")]),t._v(" "),e("p",[t._v("作用域的设置比较简单，“Domain”和“Path”指定了 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。")]),t._v(" "),e("p",[t._v("不过现实中为了省事，通常 Path 就用一个“/”或者直接省略，表示域名下的任意路径都允许使用 Cookie，让服务器自己去挑。")]),t._v(" "),e("h3",{attrs:{id:"cookie-安全属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie-安全属性"}},[t._v("#")]),t._v(" Cookie 安全属性")]),t._v(" "),e("ol",[e("li",[t._v("HttpOnly")])]),t._v(" "),e("p",[t._v("document.cookie 可以读写 Cookie 数据，一般使用属性“HttpOnly”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击（XSS）也就无从谈起了。")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("SameSite")])]),t._v(" "),e("p",[t._v("“SameSite”可以防范“跨站请求伪造”（XSRF）攻击，设置成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。")]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("Secure")])]),t._v(" "),e("p",[t._v("“Secure”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。")]),t._v(" "),e("h3",{attrs:{id:"cookie-的应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie-的应用"}},[t._v("#")]),t._v(" Cookie 的应用")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("Cookie 最基本的一个用途就是身份识别，保存用户的登录信息，实现会话事务。")])]),t._v(" "),e("li",[e("p",[t._v("Cookie 的另一个常见用途是广告跟踪。根据你看过的广告，进行分析，然后给你推广告；")])])]),t._v(" "),e("p",[t._v("虽然现在已经出现了多种 Local Web Storage 技术，能够比 Cookie 存储更多的数据，但 Cookie 仍然是最通用、兼容性最强的客户端数据存储手段。")]),t._v(" "),e("h2",{attrs:{id:"http的缓存控制-重点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http的缓存控制-重点"}},[t._v("#")]),t._v(" HTTP的缓存控制（重点）")]),t._v(" "),e("p",[t._v("缓存（Cache）是计算机领域里的一个重要概念，是优化系统性能的利器。")]),t._v(" "),e("p",[t._v("由于链路漫长，网络时延不可控，浏览器使用 HTTP 获取资源的成本较高。所以，非常有必要把“来之不易”的数据缓存起来，下次再请求的时候尽可能地复用。这样，就可以避免多次请求 - 应答的通信成本，节约网络带宽，也可以加快响应速度。")]),t._v(" "),e("p",[t._v("试想一下，如果有几十 K 甚至几十 M 的数据，不是从网络而是从本地磁盘获取，那将是多么大的一笔节省，免去多少等待的时间。")]),t._v(" "),e("p",[t._v("实际上，HTTP 传输的每一个环节基本上都会有缓存，非常复杂。")]),t._v(" "),e("p",[t._v("基于“请求 - 应答”模式的特点，可以大致分为客户端缓存和服务器端缓存，因为服务器端缓存经常与代理服务“混搭”在一起，所以我先认识客户端——也就是浏览器的缓存。")]),t._v(" "),e("h3",{attrs:{id:"服务器的缓存控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务器的缓存控制"}},[t._v("#")]),t._v(" 服务器的缓存控制")]),t._v(" "),e("ol",[e("li",[t._v("浏览器发现缓存无数据，于是发送请求，向服务器获取资源；")]),t._v(" "),e("li",[t._v("服务器响应请求，返回资源，同时标记资源的有效期；")]),t._v(" "),e("li",[t._v("浏览器缓存资源，等待下次重用。")])]),t._v(" "),e("p",[e("img",{attrs:{src:s(379),alt:"alt"}})]),t._v(" "),e("p",[t._v("服务器标记资源有效期使用的头字段是“Cache-Control”，里面的值“max-age=30”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。”")]),t._v(" "),e("p",[t._v("这里的 max-age 是“生存时间”（又叫“新鲜度”“缓存寿命”，类似 TTL，Time-To-Live），时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间。")]),t._v(" "),e("p",[t._v("比如，服务器设定“max-age=5”，但因为网络质量很糟糕，等浏览器收到响应报文已经过去了 4 秒，那么这个资源在客户端就最多能够再存 1 秒钟，之后就会失效。")]),t._v(" "),e("p",[t._v("“max-age”是 HTTP 缓存控制最常用的属性，此外在响应报文里还可以用其他的属性来更精确地指示浏览器应该如何使用缓存：")]),t._v(" "),e("ul",[e("li",[t._v("no-store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；")]),t._v(" "),e("li",[t._v("no-cache：它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；")]),t._v(" "),e("li",[t._v("must-revalidate：又是一个和 no-cache 相似的词，它的意思是如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。")])]),t._v(" "),e("p",[t._v("用买西瓜举例说明一下：")]),t._v(" "),e("ul",[e("li",[t._v("no-store：买来的西瓜（缓存）不允许放进冰箱（浏览器缓存），要么立刻吃，要么立刻扔掉；")]),t._v(" "),e("li",[t._v("no-cache：可以放进冰箱（浏览器缓存），但吃之前必须问超市（服务器）有没有更新鲜（最新）的，有就吃超市（服务器）里的；")]),t._v(" "),e("li",[t._v("must-revalidate：可以放进冰箱，保鲜期内可以吃，过期了就要问超市让不让吃。")])]),t._v(" "),e("p",[t._v("最后服务器缓存用张图来总结一下吧：")]),t._v(" "),e("p",[e("img",{attrs:{src:s(380),alt:"alt"}})]),t._v(" "),e("h3",{attrs:{id:"客户端的缓存控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#客户端的缓存控制"}},[t._v("#")]),t._v(" 客户端的缓存控制")]),t._v(" "),e("p",[t._v("其实不止服务器可以发“Cache-Control”头，浏览器也可以发“Cache-Control”，也就是说请求 - 应答的双方都可以用这个字段进行缓存控制，互相协商缓存的使用策略。")]),t._v(" "),e("p",[t._v("当你点“刷新”按钮的时候，浏览器会在请求头里加一个“Cache-Control: max-age=0”。因为 max-age 是“生存时间”，max-age=0 的意思就是“我要一个最最新鲜的西瓜”，而本地缓存里的数据至少保存了几秒钟，所以浏览器就不会使用缓存，而是向服务器发请求。服务器看到 max-age=0，也就会用一个最新生成的报文回应浏览器。")]),t._v(" "),e("p",[t._v("Ctrl+F5 的“强制刷新”又是什么样的呢？")]),t._v(" "),e("p",[t._v("它其实是发了一个“Cache-Control: no-cache”，含义和“max-age=0”基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的。")]),t._v(" "),e("p",[t._v("还有前进后退，那这几个操作与刷新有什么区别呢？")]),t._v(" "),e("p",[t._v("其实也很简单，"),e("strong",[t._v("在“前进”“后退”“跳转”这些重定向动作中浏览器不会“夹带私货”，只用最基本的请求头，没有“Cache-Control”，所以就会检查缓存，直接利用之前的资源，不再进行网络通信。而 Ctrl+F5 强制刷新和点击刷新按钮，会和服务器进行通讯发起请求。")])]),t._v(" "),e("h3",{attrs:{id:"条件请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#条件请求"}},[t._v("#")]),t._v(" 条件请求")]),t._v(" "),e("p",[t._v("浏览器用“Cache-Control”做缓存控制只能是刷新数据，不能很好地利用缓存数据，又因为缓存会失效，使用前还必须要去服务器验证是否是最新版。")]),t._v(" "),e("p",[t._v("那么该怎么做呢？")]),t._v(" "),e("p",[t._v("浏览器可以用两个连续的请求组成“验证动作”：先是一个 HEAD，获取资源的修改时间等元信息，然后与缓存数据比较，如果没有改动就使用缓存，节省网络流量，否则就再发一个 GET 请求，获取最新的版本。")]),t._v(" "),e("p",[t._v("但这样的两个请求网络成本太高了，所以 HTTP 协议就定义了一系列“If”开头的“条件请求”字段，专门用来检查验证资源是否过期，"),e("strong",[t._v("把两个请求才能完成的工作合并在一个请求里做。而且，验证的责任也交给服务器，浏览器只需“坐享其成”。")])]),t._v(" "),e("p",[t._v("条件请求一共有 5 个头字段，我们最常用的是“if-Modified-Since”和“If-None-Match”这两个。"),e("strong",[t._v("需要第一次的响应报文预先提供“Last-modified”和“ETag”，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。")])]),t._v(" "),e("p",[t._v("如果资源没有变，服务器就回应一个“304 Not Modified”，表示缓存依然有效，浏览器就可以更新一下有效期，然后放心大胆地使用缓存了。")]),t._v(" "),e("p",[t._v("总得来说，强制刷新是因为请求头里的 If-Modified-Since 和 If-None-Match 会被清空所以会返回最新数据。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(381),alt:"alt"}})]),t._v(" "),e("p",[t._v("我们拿买西瓜来比喻理解一下吧：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("你打电话给超市（服务器），“我这个西瓜是 3 天前买的，还有最新的吗？”。超市看了一下库存，说：“没有啊，我这里都是 3 天前的。”于是你就知道了，再让超市送货也没用，还是吃冰箱（浏览器）里的西瓜吧。这就是“if-Modified-Since”和“Last-modified”。")])]),t._v(" "),e("li",[e("p",[t._v("但你还是想要最新的，就又打电话：“有不是沙瓤的西瓜吗？”，超市告诉你都是沙瓤的（Match），于是你还是只能吃冰箱里的沙瓤西瓜。这就是“If-None-Match”和“弱 ETag”。")])]),t._v(" "),e("li",[e("p",[t._v("第三次打电话，你说“有不是 8 斤的沙瓤西瓜吗？”，这回超市给了你满意的答复：“有个 10 斤的沙瓤西瓜”。于是，你就扔掉了冰箱里的存货，让超市重新送了一个新的大西瓜。这就是“If-None-Match”和“强 ETag”。")])])]),t._v(" "),e("h3",{attrs:{id:"缓存控制机制-重点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存控制机制-重点"}},[t._v("#")]),t._v(" 缓存控制机制（重点）")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当前页面不缓存, 每次访问都去服务器拉取. 只有部分浏览器支持. ")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("META")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HTTP")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("EQUIV")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Pragma"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CONTENT")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"no-cache"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br")])]),e("h3",{attrs:{id:"强缓存-200-from-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存-200-from-cache"}},[t._v("#")]),t._v(" 强缓存 (200 from cache)")]),t._v(" "),e("p",[t._v("判断的字段: Expires 或 Cache-Control")]),t._v(" "),e("ul",[e("li",[t._v("Expires "),e("code",[t._v("[http 1.0 的标准]")]),t._v(",  存储的是过期的具体时间")]),t._v(" "),e("li",[t._v("Cache-Control "),e("code",[t._v("[http 1.1 的标准]")]),t._v("  max-age 值是过期的秒。 max-age 最大值不能超过1年，秒为单位， 优先级高, 以它的结果为准。")]),t._v(" "),e("li",[t._v("由于具体时间没有转换到正确的时区有可能造成错误，所以倾向于使用 Cache-Control: max-age")])]),t._v(" "),e("h3",{attrs:{id:"协商缓存-304-or-200-last-modified-或-etag"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存-304-or-200-last-modified-或-etag"}},[t._v("#")]),t._v(" 协商缓存  (304 or 200)，last-modified 或 Etag")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("响应头/请求头（last-modified/If-Modified-Since）")])]),t._v(" "),e("li",[e("p",[t._v("浏览器第一次请求数据之后,服务端在 Response Headers 会带上 Last-modified (服务端资源最后修改时间)。")])]),t._v(" "),e("li",[e("p",[t._v("再次请求时, 请求头会带上 If-Modified-Since 去跟服务器资源的最后修改时间对比。 如果修改，返回 200，否则返回 304。")])]),t._v(" "),e("li",[e("p",[t._v("其次是，响应头/请求头（Etag/If-None-Match），也是一样得。")])])]),t._v(" "),e("h3",{attrs:{id:"last-modified-和-etag-区别。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-和-etag-区别。"}},[t._v("#")]),t._v(" last-modified 和 Etag 区别。")]),t._v(" "),e("ul",[e("li",[t._v("有些服务无法精确的得到资源最后修改时间。")]),t._v(" "),e("li",[t._v("last-modified 只能精确到秒。")]),t._v(" "),e("li",[t._v("一些资源的最后修改时间改变了，但是内容没改变，使用 Last-modified 看不出内容没有改变。")]),t._v(" "),e("li",[t._v("Etag 的精度比 Last-modified 高，属于强验证，优先级高。")])]),t._v(" "),e("h3",{attrs:{id:"last-modified-和-etag-优先级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-和-etag-优先级"}},[t._v("#")]),t._v(" last-modified 和 Etag 优先级")]),t._v(" "),e("p",[t._v("一般先判断 Etag, 再判断 last-modified，但是结果会由服务器决策。")]),t._v(" "),e("h3",{attrs:{id:"一张图总结-过程省略代理缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一张图总结-过程省略代理缓存"}},[t._v("#")]),t._v(" 一张图总结，过程省略代理缓存")]),t._v(" "),e("p",[e("img",{attrs:{src:s(382),alt:"alt"}})]),t._v(" "),e("h2",{attrs:{id:"http的代理服务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http的代理服务"}},[t._v("#")]),t._v(" HTTP的代理服务")]),t._v(" "),e("p",[t._v("所谓的“代理服务”就是指服务本身不生产内容，而是处于中间位置转发上下游的请求和响应，具有双重身份：面向下游的用户时，表现为服务器，代表源服务器响应客户端的请求；而面向上游的源服务器时，又表现为客户端，代表客户端发送请求。")]),t._v(" "),e("p",[t._v("你也许听过这样一句至理名言：“计算机科学领域里的任何问题，都可以通过引入一个中间层来解决”（在这句话后面还可以再加上一句“如果一个中间层解决不了问题，那就再加一个中间层”）。TCP/IP 协议栈是这样，而代理也是这样。")]),t._v(" "),e("p",[t._v("实际工作中最常见的反向代理，它在传输链路中更靠近源服务器，为源服务器提供代理服务。")]),t._v(" "),e("h3",{attrs:{id:"代理服务器的缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理服务器的缓存"}},[t._v("#")]),t._v(" 代理服务器的缓存")]),t._v(" "),e("p",[t._v("但客户端和代理是不一样的，客户端的缓存只是用户自己使用，而代理的缓存可能会为非常多的客户端提供服务。所以，需要对它的缓存再多一些限制条件。")]),t._v(" "),e("p",[t._v("我们要区分客户端上的缓存和代理上的缓存，可以使用两个新属性“private”和“public”。")]),t._v(" "),e("p",[t._v("“private”表示缓存只能在客户端保存，是用户“私有”的，不能放在代理上与别人共享。而“public”的意思就是缓存完全开放，谁都可以存，谁都可以用。直接来看一张图吧")]),t._v(" "),e("p",[e("img",{attrs:{src:s(383),alt:"alt"}})]),t._v(" "),e("p",[t._v("注意一点，"),e("strong",[t._v("源服务器在设置完“Cache-Control”后必须要为报文加上“Last-modified”或“ETag”字段。否则，客户端和代理后面就无法使用条件请求来验证缓存是否有效，也就不会有 304 缓存重定向。")])]),t._v(" "),e("h2",{attrs:{id:"http-2-特性橄榄"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-2-特性橄榄"}},[t._v("#")]),t._v(" HTTP/2 特性橄榄")]),t._v(" "),e("p",[t._v("因为SSL/TLS在安全上已经做得很好了，但是在性能上只能优化握手环节，本质上并不能改变HTTP/1依赖长连接导致队头阻塞的问题；")]),t._v(" "),e("p",[t._v("为了不造成混乱和误解，HTTP协议版本号不再使用小版本号，如HTTP/2.0这样的小版本号，直接以HTTP/1,HTTP/2这样的形式；")]),t._v(" "),e("h3",{attrs:{id:"兼容-http-1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#兼容-http-1"}},[t._v("#")]),t._v(" 兼容 HTTP/1")]),t._v(" "),e("p",[t._v("由于HTTPS在安全方面已经做得不错了，所有HTTP/2主要是改进HTTP/1存在的性能问题；又因为HTTP/1的强大历史包袱，普及率实在很高，如果盲目改进，会造成很多互联网上的资源流失，所以必须得兼容HTTP/1")]),t._v(" "),e("p",[t._v("那么，HTTP/2又是怎么做的呢？")]),t._v(" "),e("p",[t._v("因为必须要保持功能上的兼容，所以 HTTP/2 把 HTTP 分解成了“语义”和“语法”两个部分，“语义”层不做改动，与 HTTP/1 完全一致（即 RFC7231）。比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。")]),t._v(" "),e("p",[t._v("特别要说的是，与 HTTPS 不同，HTTP/2 没有在 URI 里引入新的协议名，仍然用“http”表示明文协议，用“https”表示加密协议。")]),t._v(" "),e("p",[t._v("这是一个非常了不起的决定，可以让浏览器或者服务器去自动升级或降级协议，免去了选择的麻烦，让用户在上网的时候都意识不到协议的切换，实现平滑过渡。")]),t._v(" "),e("p",[t._v("在“语义”保持稳定之后，HTTP/2 在“语法”层做了“天翻地覆”的改造，完全变更了 HTTP 报文的传输格式。")]),t._v(" "),e("h3",{attrs:{id:"头部压缩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#头部压缩"}},[t._v("#")]),t._v(" 头部压缩")]),t._v(" "),e("p",[t._v("首先，HTTP/1头部是个不折不扣的大头儿子，完全没有优化手段；\n头部字段动不动就是几百字节甚至上千字节（如GET请求下的204/301/304），但 Body 却经常只有几十字节。")]),t._v(" "),e("p",[t._v("所以，HTTP/2 把“头部压缩”作为性能改进的一个重点，采用专门的“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。")]),t._v(" "),e("h3",{attrs:{id:"二进制格式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二进制格式"}},[t._v("#")]),t._v(" 二进制格式")]),t._v(" "),e("p",[t._v("HTTP/1 是纯文本形式的报文，HTTP/2 改变延续了十多年的现状，不再使用肉眼可见的 ASCII 码，而是向下层的 TCP/IP 协议“靠拢”，全面采用二进制格式。")]),t._v(" "),e("p",[t._v("虽然二进制格式的报文对人不优化，但是对于计算机解析来说，却快捷简单了很多，同时体积也非常的小；所以HTTP/2就以二进制格式为基础，把 TCP 协议的部分特性挪到了应用层，把原来的“Header+Body”的消息“打散”为数个小片的二进制“帧”（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放实体数据。有点像“Chunked”分块编码的方式，采用“化整为零”的思路。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(384),alt:"alt"}})]),t._v(" "),e("h3",{attrs:{id:"虚拟的-流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟的-流"}},[t._v("#")]),t._v(" 虚拟的“流”")]),t._v(" "),e("p",[t._v("消息的“碎片”到达目的地后应该怎么组装起来呢？")]),t._v(" "),e("p",[t._v("HTTP/2 为此定义了一个“流”（Stream）的概念，它是二进制帧的双向传输序列，同一个消息往返的帧会分配一个唯一的流 ID。你可以把它想象成是一个虚拟的“数据流”，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文。")]),t._v(" "),e("p",[t._v("因为“流”是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息，这就是常说的“多路复用”（ Multiplexing）——多个往返通信都复用一个连接来处理。")]),t._v(" "),e("p",[t._v("**在“流”的层面上看，消息是一些有序的“帧”序列，而在“连接”的层面上看，消息却是乱序收发的“帧”。**多个请求 / 响应之间没有了顺序关系，不需要排队等待，也就不会再出现“队头阻塞”问题，降低了延迟，大幅度提高了连接的利用率。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(385),alt:"alt"}})]),t._v(" "),e("p",[t._v("为了更好地利用连接，加大吞吐量，HTTP/2 还添加了一些控制帧来管理虚拟的“流”，实现了优先级和流量控制，这些特性也和 TCP 协议非常相似。")]),t._v(" "),e("p",[t._v("HTTP/2 还在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）。")]),t._v(" "),e("h3",{attrs:{id:"强化安全"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强化安全"}},[t._v("#")]),t._v(" 强化安全")]),t._v(" "),e("p",[t._v("出于兼容性考虑，HTTP/2延续了HTTP/1的明文特点，不强制要求加密通许，只不过格式还是二进制；")]),t._v(" "),e("p",[t._v("但由于HTTPS已经大势所趋，主流的浏览器 Chrome、Firefox 等都公开宣布只支持加密的 HTTP/2，所以“事实上”的 HTTP/2 是加密的。也就是说，互联网上通常所能见到的 HTTP/2 都是使用“https”协议名，跑在 TLS 上面。")]),t._v(" "),e("p",[t._v("为了区分“加密”和“明文”这两个不同的版本，HTTP/2 协议定义了两个字符串标识符：“h2”表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2，多出的那个字母“c”的意思是“clear text”。")]),t._v(" "),e("p",[t._v("在 HTTP/2 标准制定的时候（2015 年）已经发现了很多 SSL/TLS 的弱点，而新的 TLS1.3 还未发布，所以加密版本的 HTTP/2 在安全方面做了强化，要求下层的通信协议必须是 TLS1.2 以上，还要支持前向安全和 SNI，并且把几百个弱密码套件列入了“黑名单”，比如 DES、RC4、CBC、SHA-1 都不能在 HTTP/2 里使用，相当于底层用的是“TLS1.25”。")]),t._v(" "),e("h3",{attrs:{id:"协议栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协议栈"}},[t._v("#")]),t._v(" 协议栈")]),t._v(" "),e("p",[t._v("下面的这张图对比了 HTTP/1、HTTPS 和 HTTP/2 的协议栈，你可以清晰地看到，HTTP/2 是建立在“HPack”“Stream”“TLS1.2”基础之上的，比 HTTP/1、HTTPS 复杂了一些。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(386),alt:"alt"}})]),t._v(" "),e("p",[t._v("虽然 HTTP/2 的底层实现很复杂，但它的“语义”还是简单的 HTTP/1，之前学习的知识不会过时，仍然能够用得上。")]),t._v(" "),e("h3",{attrs:{id:"小结一下http-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结一下http-2"}},[t._v("#")]),t._v(" 小结一下HTTP/2")]),t._v(" "),e("ol",[e("li",[t._v("HTTP 协议取消了小版本号，所以 HTTP/2 的正式名字不是 2.0；")]),t._v(" "),e("li",[t._v("HTTP/2 在“语义”上兼容 HTTP/1，保留了请求方法、URI 等传统概念；")]),t._v(" "),e("li",[t._v("HTTP/2 使用“HPACK”算法压缩头部信息，消除冗余数据节约带宽；")]),t._v(" "),e("li",[t._v("HTTP/2 的消息不再是“Header+Body”的形式，而是分散为多个二进制“帧”；")]),t._v(" "),e("li",[t._v("HTTP/2 使用虚拟的“流”传输消息，解决了困扰多年的“队头阻塞”问题，同时实现了“多路复用”，提高连接的利用率；")]),t._v(" "),e("li",[t._v("HTTP/2 也增强了安全性，要求至少是 TLS1.2，而且禁用了很多不安全的密码套件。")])]),t._v(" "),e("h2",{attrs:{id:"http-2-内核剖析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-2-内核剖析"}},[t._v("#")]),t._v(" HTTP/2 内核剖析")]),t._v(" "),e("h3",{attrs:{id:"连接前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#连接前言"}},[t._v("#")]),t._v(" 连接前言")]),t._v(" "),e("p",[e("img",{attrs:{src:s(387),alt:"alt"}})]),t._v(" "),e("p",[t._v("TLS 握手成功之后，客户端必须要发送一个“连接前言”（connection preface），用来确认建立 HTTP/2 连接。")]),t._v(" "),e("p",[t._v("这个“连接前言”是标准的 HTTP/1 请求报文，使用纯文本的 ASCII 码格式，请求方法是特别注册的一个关键字“PRI”，全文只有 24 个字节：")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("PRI")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HTTP")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.0")]),t._v("\\r\\n\\r\\nSM\\r\\n\\r\\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("在 Wireshark 里，HTTP/2 的“连接前言”被称为“Magic”，意思就是“不可知的魔法”。")]),t._v(" "),e("p",[t._v("所以，就不要问“为什么会是这样”了，只要服务器收到这个“有魔力的字符串”，就知道客户端在 TLS 上想要的是 HTTP/2 协议，而不是其他别的协议，后面就会都使用 HTTP/2 的数据格式。")]),t._v(" "),e("h3",{attrs:{id:"头部压缩-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#头部压缩-2"}},[t._v("#")]),t._v(" 头部压缩")]),t._v(" "),e("p",[t._v("确立了连接之后，HTTP/2 就开始准备请求报文。")]),t._v(" "),e("p",[t._v("因为语义上它与 HTTP/1 兼容，所以报文还是由“Header+Body”构成的，但在请求发送前，必须要用“HPACK”算法来压缩头部数据。")]),t._v(" "),e("p",[t._v("“HPACK”算法是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib 等压缩算法不同，它是一个“有状态”的算法，需要客户端和服务器各自维护一份“索引表”，也可以说是“字典”（这有点类似 brotli），压缩和解压缩就是查表和更新表的操作。")]),t._v(" "),e("p",[t._v("为了方便管理和压缩，HTTP/2 废除了原有的起始行概念，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，并且给这些“不是头字段的头字段”起了个特别的名字——“伪头字段”（pseudo-header fields）。而起始行里的版本号和错误原因短语因为没什么大用，顺便也给废除了。")]),t._v(" "),e("p",[t._v("为了与“真头字段”区分开来，这些“伪头字段”会在名字前加一个“:”，比如“:authority” “:method” “:status”，分别表示的是域名、请求方法和状态码。")]),t._v(" "),e("p",[t._v("现在 HTTP 报文头就简单了，全都是“Key-Value”形式的字段，于是 HTTP/2 就为一些最常用的头字段定义了一个只读的“静态表”（Static Table）。")]),t._v(" "),e("p",[t._v("下面的这个表格列出了“静态表”的一部分，这样只要查表（客户端和服务端都自己维护一个表）就可以知道字段名和对应的值，比如数字“2”代表“GET”，数字“8”代表状态码 200。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(388),alt:"alt"}})]),t._v(" "),e("p",[t._v("但如果表里只有 Key 没有 Value，或者是自定义字段根本找不到该怎么办呢？")]),t._v(" "),e("p",[t._v("这就要用到“动态表”（Dynamic Table），它添加在静态表后面，结构相同，但会在编码解码的时候随时更新。")]),t._v(" "),e("p",[t._v("比如说，第一次发送请求时的“user-agent”字段长是一百多个字节，用哈夫曼压缩编码发送之后，客户端和服务器都更新自己的动态表，添加一个新的索引号“65”。那么下一次发送的时候就不用再重复发那么多字节了，只要用一个字节发送编号就好。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(389),alt:"alt"}})]),t._v(" "),e("p",[t._v("你可以想象得出来，随着在 HTTP/2 连接上发送的报文越来越多，两边的“字典”也会越来越丰富，最终每次的头部字段都会变成一两个字节的代码，原来上千字节的头用几十个字节就可以表示了，压缩效果比 gzip 要好得多。")]),t._v(" "),e("h3",{attrs:{id:"二进制帧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二进制帧"}},[t._v("#")]),t._v(" 二进制帧")]),t._v(" "),e("p",[t._v("头部数据压缩之后，HTTP/2 就要把报文拆成二进制的帧准备发送。")]),t._v(" "),e("p",[t._v("HTTP/2 的帧结构有点类似 TCP 的段或者 TLS 里的记录，但报头很小，只有 9 字节，非常地节省（可以对比一下 TCP 头，它最少是 20 个字节）。二进制的格式也保证了不会有歧义，而且使用位运算能够非常简单高效地解析。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(390),alt:"alt"}})]),t._v(" "),e("ol",[e("li",[t._v("帧长度：HTTP/2 的帧（不包括头的 9 个字节）通常不超过 16K，最大是 16M。默认上限是 2^14，最大是 2^24，")]),t._v(" "),e("li",[t._v("帧类型：大致可以分成数据帧和控制帧两类，HEADERS 帧和 DATA 帧属于数据帧，存放的是 HTTP 报文，而 SETTINGS、PING、PRIORITY 等则是用来管理流的控制帧。HTTP/2 总共定义了 10 种类型的帧，剩下的可扩展。")]),t._v(" "),e("li",[t._v("帧标志：可以保存 8 个标志位，携带简单的控制信息。")])]),t._v(" "),e("ul",[e("li",[t._v("常用的标志位有 END_HEADERS 表示头数据结束，相当于 HTTP/1 里头后的空行（“\\r\\n”），END_STREAM 表示单方向数据发送结束（即 EOS，End of Stream），相当于 HTTP/1 里 Chunked 分块结束标志（“0\\r\\n\\r\\n”）。")])]),t._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[t._v("流标识符：也就是帧所属的“流”，接收方使用它就可以从乱序的帧里识别出具有相同流 ID 的帧序列，按顺序组装起来就实现了虚拟的“流”。也就是靠流实现了多路复用。")])]),t._v(" "),e("ul",[e("li",[t._v("流标识符虽然有 4 个字节，但最高位被保留不用，所以只有 31 位可以使用，也就是说，流标识符的上限是 2^31，大约是 21 亿。")])]),t._v(" "),e("p",[t._v("好了，把二进制头理清楚后，我们来看一下 Wireshark 抓包的帧实例：\n"),e("img",{attrs:{src:s(391),alt:"alt"}})]),t._v(" "),e("ul",[e("li",[e("p",[t._v("长度：在这个帧里，开头的三个字节是“00010a”，表示数据长度是 266 字节。")])]),t._v(" "),e("li",[e("p",[t._v("帧类型：是 1，表示 HEADERS 帧，负载（payload）里面存放的是被 HPACK 算法压缩的头部信息。")])]),t._v(" "),e("li",[e("p",[t._v("标志位：是 0x25，转换成二进制有 3 个位被置 1。PRIORITY 表示设置了流的优先级，END_HEADERS 表示这一个帧就是完整的头数据，END_STREAM 表示单方向数据发送结束，后续再不会有数据帧（即请求报文完毕，不会再有 DATA 帧 /Body 数据）。")])]),t._v(" "),e("li",[e("p",[t._v("流标识符：最后 4 个字节的流标识符是整数 1，表示这是客户端发起的第一个流，后面的响应数据帧也会是这个 ID，也就是说在 stream[1]里完成这个请求响应。")])])]),t._v(" "),e("h3",{attrs:{id:"流与多路复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#流与多路复用"}},[t._v("#")]),t._v(" 流与多路复用")]),t._v(" "),e("p",[t._v("弄清楚了帧结构后我们就来看 HTTP/2 的流与多路复用，它是 HTTP/2 最核心的部分。这里再重复一遍："),e("strong",[t._v("流是二进制帧的双向传输序列。")])]),t._v(" "),e("p",[t._v("要搞明白流，关键是要理解帧头里的流 ID。")]),t._v(" "),e("p",[t._v("在 HTTP/2 连接上，虽然帧是乱序收发的，但只要它们都拥有相同的流 ID，就都属于一个流，而且在这个流里帧不是无序的，而是有着严格的先后顺序。")]),t._v(" "),e("p",[t._v("比如在这次的 Wireshark 抓包里，就有“0、1、3”一共三个流，实际上就是分配了三个流 ID 号，把这些帧按编号分组，再排一下队，就成了流。注意发送是乱序的，没有先后的关系。\n"),e("img",{attrs:{src:s(392),alt:"alt"}})]),t._v(" "),e("p",[t._v("在概念上，一个 HTTP/2 的流就等同于一个 HTTP/1 里的“请求 - 应答”。在 HTTP/1 里一个“请求 - 响应”报文来回是一次 HTTP 通信，在 HTTP/2 里一个流也承载了相同的功能。")]),t._v(" "),e("p",[t._v("你还可以对照着 TCP 来理解。TCP 运行在 IP 之上，其实从 MAC 层、IP 层的角度来看，TCP 的“连接”概念也是“虚拟”的。但从功能上看，无论是 HTTP/2 的流，还是 TCP 的连接，都是实际存在的，所以你以后大可不必再纠结于流的“虚拟”性，把它当做是一个真实存在的实体来理解就好。")]),t._v(" "),e("p",[t._v("那HTTP/2 的流有哪些特点呢？我们总结一下：")]),t._v(" "),e("ol",[e("li",[t._v("流是可并发的，一个 HTTP/2 连接上可以同时发出多个流传输数据，也就是并发多请求，实现“多路复用”；")]),t._v(" "),e("li",[t._v("客户端和服务器都可以创建流，双方互不干扰；")]),t._v(" "),e("li",[t._v("流是双向的，一个流里面客户端和服务器都可以发送或接收数据帧，也就是一个“请求 - 应答”来回；")]),t._v(" "),e("li",[t._v("流之间没有固定关系，彼此独立，但流内部的帧是有严格顺序的；")]),t._v(" "),e("li",[t._v("流可以设置优先级，让服务器优先处理，比如先传 HTML/CSS，后传图片，优化用户体验；")]),t._v(" "),e("li",[t._v("流 ID 不能重用，只能顺序递增，客户端发起的 ID 是奇数，服务器端发起的 ID 是偶数；")]),t._v(" "),e("li",[t._v("在流上发送“RST_STREAM”帧可以随时终止流，取消接收或发送；")]),t._v(" "),e("li",[t._v("第 0 号流比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用于流量控制。")])]),t._v(" "),e("p",[t._v("来张图理解一下吧\n"),e("img",{attrs:{src:s(393),alt:"alt"}})]),t._v(" "),e("p",[t._v("从这些特性中，我们还可以推理出一些深层次的知识点。")]),t._v(" "),e("p",[t._v("比如说，HTTP/2 在一个连接上使用多个流收发数据，那么它本身默认就会是长连接，所以永远不需要“Connection”头字段（keepalive 或 close）。")]),t._v(" "),e("p",[t._v("又比如，下载大文件的时候想取消接收，在 HTTP/1 里只能断开 TCP 连接重新“三次握手”，成本很高，而在 HTTP/2 里就可以简单地发送一个“RST_STREAM”中断流，而长连接会继续保持。")]),t._v(" "),e("p",[t._v("再比如，因为客户端和服务器两端都可以创建流，而流 ID 有奇数偶数和上限的区分，所以大多数的流 ID 都会是奇数，而且客户端在一个连接里最多只能发出 2^30，也就是 10 亿个请求。ID 用完了该怎么办呢？这个时候可以再发一个控制帧“GOAWAY”，真正关闭 TCP 连接。")]),t._v(" "),e("h3",{attrs:{id:"流状态转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#流状态转换"}},[t._v("#")]),t._v(" 流状态转换")]),t._v(" "),e("p",[t._v("流很重要，也很复杂。为了更好地描述运行机制，HTTP/2 借鉴了 TCP，根据帧的标志位实现流状态转换。当然，这些状态也是虚拟的，只是为了辅助理解。")]),t._v(" "),e("p",[t._v("HTTP/2 的流也有一个状态转换图，虽然比 TCP 要简单一点，但也不那么好懂，所以今天我只画了一个简化的图，对应到一个标准的 HTTP“请求 - 应答”。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(394),alt:"alt"}})]),t._v(" "),e("p",[t._v("最开始的时候流都是“空闲”（idle）状态，也就是“不存在”，可以理解成是待分配的“号段资源”。")]),t._v(" "),e("p",[t._v("当客户端发送 HEADERS 帧后，有了流 ID，流就进入了“打开”状态，两端都可以收发数据，然后客户端发送一个带“END_STREAM”标志位的帧，流就进入了“半关闭”状态。")]),t._v(" "),e("p",[t._v("这个“半关闭”状态很重要，意味着客户端的请求数据已经发送完了，需要接受响应数据，而服务器端也知道请求数据接收完毕，之后就要内部处理，再发送响应数据。")]),t._v(" "),e("p",[t._v("响应数据发完了之后，也要带上“END_STREAM”标志位，表示数据发送完毕，这样流两端就都进入了“关闭”状态，流就结束了。")]),t._v(" "),e("p",[t._v("特别注意，流 ID 不能重用，所以流的生命周期就是 HTTP/1 里的一次完整的“请求 - 应答”，流关闭就是一次通信结束。")]),t._v(" "),e("p",[t._v("下一次再发请求就要开一个新流（而不是新连接），流 ID 不断增加，直到到达上限，发送“GOAWAY”帧开一个新的 TCP 连接，流 ID 就又可以重头计数。")]),t._v(" "),e("p",[t._v("你再看看这张图，是不是和 HTTP/1 里的标准“请求 - 应答”过程很像，只不过这是发生在虚拟的“流”上，而不是实际的 TCP 连接，又因为流可以并发，所以 HTTP/2 就可以实现无阻塞的多路复用。")]),t._v(" "),e("h3",{attrs:{id:"小结http-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结http-2"}},[t._v("#")]),t._v(" 小结HTTP/2")]),t._v(" "),e("p",[t._v("HTTP/2 内容远远不止这些，比如流的优先级、依赖关系、流量控制等等，需要多看RFC文档。")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("HTTP/2 必须先发送一个“连接前言”字符串，然后才能建立正式连接；")])]),t._v(" "),e("li",[e("p",[t._v("HTTP/2 废除了起始行，统一使用头字段，在两端维护字段“Key-Value”的索引表，使用“HPACK”算法压缩头部；")])]),t._v(" "),e("li",[e("p",[t._v("HTTP/2 把报文切分为多种类型的二进制帧，报头里最重要的字段是流标识符，标记帧属于哪个流；")])]),t._v(" "),e("li",[e("p",[t._v("流是 HTTP/2 虚拟的概念，是帧的双向传输序列，相当于 HTTP/1 里的一次“请求 - 应答”；")])]),t._v(" "),e("li",[e("p",[t._v("在一个 HTTP/2 连接上可以并发多个流，也就是多个“请求 - 响应”报文，这就是“多路复用”。")])])]),t._v(" "),e("h2",{attrs:{id:"应该迁移到-http-2-吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应该迁移到-http-2-吗"}},[t._v("#")]),t._v(" 应该迁移到 HTTP/2 吗？")]),t._v(" "),e("p",[t._v("先来看看优点吧")]),t._v(" "),e("ol",[e("li",[t._v("完全保持了与 HTTP/1 的兼容，在语义上没有任何变化，之前在 HTTP 上的所有投入都不会浪费。")]),t._v(" "),e("li",[t._v("基本”解决了 HTTP/1 的所有缺点，安全与性能兼顾；下层的 TLS 至少是 1.2，而且只能使用前向安全的密码套件（即 ECDHE），这同时也就默认实现了“TLS False Start”，支持 1-RTT 握手，所以不需要再加额外的配置就可以自动实现 HTTPS 加速。")]),t._v(" "),e("li",[t._v("影响网络速度的两个关键因素是“带宽”和“延迟”，HTTP/2 的头部压缩、多路复用、流优先级、服务器推送等手段其实都是针对这两个要点。")]),t._v(" "),e("li",[t._v("节约带宽的基本手段就是压缩，在 HTTP/1 里只能压缩 body，而 HTTP/2 则可以用 HPACK 算法压缩 header；")]),t._v(" "),e("li",[t._v("与 HTTP/1“并发多个连接”不同，HTTP/2 的“多路复用”特性要求对一个域名（或者 IP）只用一个 TCP 连接，所有的数据都在这一个连接上传输，这样不仅节约了客户端、服务器和网络的资源，还可以把带宽跑满，让 TCP 充分“吃饱”。")])]),t._v(" "),e("p",[t._v("再来看看缺点吧")]),t._v(" "),e("ol",[e("li",[t._v("HTTP/2 在 TCP 级别还是存在“队头阻塞”的问题。所以，如果网络连接质量差，发生丢包，那么 TCP 会等待重传，传输速度就会降低。")]),t._v(" "),e("li",[t._v("网络中发生 IP 地址切换的时候，下层的 TCP 必须重新建连，要再次“握手”，经历“慢启动”，而且之前连接里积累的 HPACK 字典也都消失了，必须重头开始计算，导致带宽浪费和时延。")]),t._v(" "),e("li",[t._v("HTTP/2 对一个域名只开一个连接，所以一旦这个连接出问题，那么整个网站的体验也就变差了。而这些情况下 HTTP/1 反而不会受到影响，因为它“本来就慢”，而且还会对一个域名开 6~8 个连接，顶多其中的一两个连接会“更慢”，其他的连接不会受到影响。")])]),t._v(" "),e("h3",{attrs:{id:"应该迁移到http-2吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应该迁移到http-2吗"}},[t._v("#")]),t._v(" 应该迁移到HTTP/2吗？")]),t._v(" "),e("p",[t._v("虽然它处于比较尴尬的位置，前有HTTP/1老前辈，后有HTTP/3新秀，但是它是完全兼容HTTP/1的，同时在一些技术上和HTTP/3也一样；\n所以对于流量大的网站，很有必要升级，但是同时要考虑一下运维成本，如果是新网站，完全不用顾虑了，目前TOP 1000的网站已有40%的升级到了HTTP/2。")]),t._v(" "),e("h3",{attrs:{id:"小结http-2-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结http-2-2"}},[t._v("#")]),t._v(" 小结HTTP/2")]),t._v(" "),e("ol",[e("li",[t._v("HTTP/2 完全兼容 HTTP/1，是“更安全的 HTTP、更快的 HTTPS”，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；")]),t._v(" "),e("li",[t._v("TCP 协议存在“队头阻塞”，所以 HTTP/2 在弱网或者移动网络下的性能表现会不如 HTTP/1；")]),t._v(" "),e("li",[t._v("迁移到 HTTP/2 肯定会有性能提升，但高流量网站效果会更显著；")]),t._v(" "),e("li",[t._v("如果已经升级到了 HTTPS，那么再升级到 HTTP/2 会很简单(浏览器根据 TLS 的扩展里“ALPN”进行协商，前提是 TLS 握手后)；")]),t._v(" "),e("li",[t._v("TLS 协议提供“ALPN”扩展，让客户端和服务器协商使用的应用层协议，“发现”HTTP/2 服务。")])]),t._v(" "),e("h3",{attrs:{id:"注意点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#注意点"}},[t._v("#")]),t._v(" 注意点")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("图片就算很多，在 HTTP/2 也可以做到 “并发”。使用了精灵图的话，首先文件变大了，在 HTTP/2 中相比分开请求要更慢，而且不利于缓存（比如修改了其中几个图片）。")])]),t._v(" "),e("li",[e("p",[t._v("资源内联，是指将一个资源作为另一个资源的一部分，使二者作为一个整体的资源来请求，比如 HTML 文件里嵌入 base64 的图片，该方案是为了减少 HTTP/1 下的请求数，加快网页响应时间。HTTP/2 不存在网页加载变慢的情况，而且不内联的话，能更好地发挥缓存的优势（比如图片是固定的，但 HTML 是动态的）。")])]),t._v(" "),e("li",[e("p",[t._v("域名分片。域名分片对于http/2会增加连接成本、HPack字典、慢启动等多个不利因素，所以应该少用。")])])]),t._v(" "),e("h3",{attrs:{id:"waf-保护我们的网络服务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#waf-保护我们的网络服务"}},[t._v("#")]),t._v(" WAF：保护我们的网络服务")]),t._v(" "),e("ol",[e("li",[t._v("“DDoS”攻击（distributed denial-of-service attack），有时候也叫“洪水攻击”。利用僵尸计算机发起合法的无效请求。")]),t._v(" "),e("li",[t._v("因为HTTP过于灵活，URI 里的 query 字符串、头字段、body 数据都可以任意设置，这就带来了安全隐患，给了黑客“代码注入”的可能性。")])]),t._v(" "),e("ul",[e("li",[t._v("“SQL 注入”（SQL injection）应该算是最著名的一种“代码注入”攻击了，它利用了服务器字符串拼接形成 SQL 语句的漏洞，构造出非正常的 SQL 语句，获取数据库内部的敏感信息。")]),t._v(" "),e("li",[t._v("“HTTP 头注入”攻击的方式也是类似的原理，它在“Host”“User-Agent”“X-Forwarded-For”等字段里加入了恶意数据或代码，服务端程序如果解析不当，就会执行预设的恶意代码。")])]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("“跨站脚本”（XSS）攻击，它属于“JS 代码注入”，利用 JavaScript 脚本获取未设防的 Cookie。")])]),t._v(" "),e("h3",{attrs:{id:"网络应用防火墙"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络应用防火墙"}},[t._v("#")]),t._v(" 网络应用防火墙")]),t._v(" "),e("p",[t._v("HTTPS的核心工作是加密解密通过HTTPS传输的内容，保证传输的内容是完整安全的，至于内容是一个“炸弹”还是一把“匕首”它是管不着的。面对这么多的黑客攻击手段，我们应该怎么防御呢？")]),t._v(" "),e("p",[t._v("这就要用到“网络应用防火墙”（Web Application Firewall）了，简称为“WAF”。")]),t._v(" "),e("p",[t._v("你可能对传统的“防火墙”比较熟悉。传统“防火墙”工作在三层或者四层，隔离了外网和内网，使用预设的规则，只允许某些特定 IP 地址和端口号的数据包通过，拒绝不符合条件的数据流入或流出内网，实质上是一种网络数据过滤设备。")]),t._v(" "),e("p",[t._v("WAF 也是一种“防火墙”，但它工作在七层，看到的不仅是 IP 地址和端口号，但能看到整个 HTTP 报文，所以就能够对报文内容做更深入细致的审核，使用更复杂的条件、规则来过滤数据。")]),t._v(" "),e("p",[t._v("说白了，WAF 就是一种“HTTP 入侵检测和防御系统”。通常一款产品能够称为 WAF，要具备下面的一些功能：")]),t._v(" "),e("ol",[e("li",[t._v("IP 黑名单和白名单，拒绝黑名单上地址的访问，或者只允许白名单上的用户访问；")]),t._v(" "),e("li",[t._v("URI 黑名单和白名单，与 IP 黑白名单类似，允许或禁止对某些 URI 的访问；")]),t._v(" "),e("li",[t._v("防护 DDoS 攻击，对特定的 IP 地址限连限速；")]),t._v(" "),e("li",[t._v("过滤请求报文，防御“代码注入”攻击；")]),t._v(" "),e("li",[t._v("过滤响应报文，防御敏感信息外泄；")]),t._v(" "),e("li",[t._v("审计日志，记录所有检测到的入侵操作。")])]),t._v(" "),e("h3",{attrs:{id:"全面的-waf-解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全面的-waf-解决方案"}},[t._v("#")]),t._v(" 全面的 WAF 解决方案")]),t._v(" "),e("p",[t._v("通常我们自己造轮子就可以抵御一些攻击，但是网络安全是个木桶效应，所以不建议自己造轮子；")]),t._v(" "),e("p",[t._v("使用一些成熟的开源库即可，像 ModSecurity，它可以说是 WAF 界“事实上的标准”。")]),t._v(" "),e("h3",{attrs:{id:"直接小结一下吧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#直接小结一下吧"}},[t._v("#")]),t._v(" 直接小结一下吧")]),t._v(" "),e("ol",[e("li",[t._v("Web 服务通常都运行在公网上，容易受到“DDoS”、“代码注入”等各种黑客攻击，影响正常的服务，所以必须要采取措施加以保护；")]),t._v(" "),e("li",[t._v("WAF 是一种“HTTP 入侵检测和防御系统”，工作在七层，为 Web 服务提供全面的防护；")]),t._v(" "),e("li",[t._v("ModSecurity 是一个开源的、生产级的 WAF 产品，核心组成部分是“规则引擎”和“规则集”，两者的关系有点像杀毒引擎和病毒特征库；")]),t._v(" "),e("li",[t._v("WAF 实质上是模式匹配与数据过滤，所以会消耗 CPU，增加一些计算成本，降低服务能力，使用时需要在安全与性能之间找到一个“平衡点”。")])])])}),[],!1,null,null,null);a.default=v.exports}}]);